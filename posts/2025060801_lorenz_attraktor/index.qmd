---
title: "Der Lorenz-Attraktor, eine Ikone der Chaos-Theorie, mit TigerJython"
author: "J√∂rg Kantel"
date: "2025-06-08 17:15:00"
categories: [Python, TigerJython, Mathematik, Dynamische Systeme, Creative Coding]
image: "images/lorenz.jpg"
---

[![](images/lorenz-b.jpg)](https://www.flickr.com/photos/schockwellenreiter/54575243149/)

Das Abenteuer [TigerJython](http://cognitiones.kantel-chaos-team.de/programmierung/python/tigerjython.html) geht weiter, heute mit einer Ikone der Chaos-Forschung, dem [Lorenz-Attraktor](https://de.wikipedia.org/wiki/Lorenz-Attraktor). Als einer der ersten hatte 1961 *[Edward N. Lorenz](http://de.wikipedia.org/wiki/Edward%20N.%20Lorenz)*, ein Meteorologe am [Massachusetts Institute of Technology](http://de.wikipedia.org/wiki/Massachusetts%20Institute%20of%20Technology) (MIT), erkannt, da√ü Iteration Chaos erzeugt. Er benutzte dort einen Computer, um ein einfaches nichtlineares Gleichungssystem zu l√∂sen, das ein simples Modell der Luftstr√∂mungen in der Erdatmosph√§re simulieren sollte. Dazu benutzte er ein System von sieben Differentialgleichungen, das *Barry Saltzman* im gleichen Jahr aus den [Navier-Stokes-Gleichungen](http://de.wikipedia.org/wiki/Navier-Stokes-Gleichungen)[^1] hergeleitet hatte. F√ºr dieses System existierte keine analytische L√∂sung, also mu√üte es numerisch (das hie√ü wie damals und auch heute noch vielfach √ºblich in FORTRAN) gel√∂st werden. Lorenz hatte entdeckt, da√ü bei nichtperiodischen L√∂sungen der Gleichungen vier der sieben Variablen gegen Null strebten. Daher konnte er das System auf drei Gleichungen reduzieren:

[^1]: Eine sehr sch√∂ne Einf√ºhrung in das [ungel√∂ste Problem der Navier-Stokes-Gleichungen](http://scienceblogs.de/astrodicticum-simplex/2017/01/20/sternengeschichten-folge-217-das-ungeloeste-problem-der-navier-stokes-gleichungen/) findet Ihr bei *Florian Freistetter* in der 217. Folge seiner Sternengeschichten

$$
\begin{aligned}
\frac{dx}{dt} &= -\sigma (y - z) \\
\frac{dy}{dt} &= (\rho - z)x - y \\
\frac{dz}{dt} &= xy - \gamma z
\end{aligned}
$$

Dabei sind $\sigma = -10$, $\rho = 40$ und $\gamma = - \frac{8}{3}$. Die Parameter der Gleichung habe ich *Herm1994*[^2] entnommen, *Stew1993*[^3] gibt $\rho = 28$ an, aber der Wert √§ndert nichts an dem Verhalten der Kurve und $\rho = 40$ f√ºllt das Fenster einfach besser aus.&nbsp;üòú

[^2]: Dietmar Hermann: *Algorithmen f√ºr Chaos und Fraktale*, Bonn (Addison-Wesley) 1994, S. 80ff.
[^3]: Ian Stewart: *Spielt Gott Roulette?* Frankfurt (Insel TB) 1993, S. 141ff.

Nach ersten L√§ufen gab Lorenz die Anfangswerte nicht mehr sechstellig (das war damals der FORTRAN-Standard), sondern nur noch dreistellig ein, da er der Meinung war, da√ü eine Abweichung von unter einem Promille keine Bedeutung habe.

Dabei entdeckte er, da√ü diese L√∂sung nur noch in den Anfangswerten mit der L√∂sung der sechsstelligen Eingabe √ºbereinstimmte. Alle weiteren Werte liefen betr√§chtlich auseinander. Lorenz grundlegende Erkenntnis war, da√ü dieses Ph√§nomen kein Computerfehler, sondern eine prinzipielle Eigenschaft nichtlinearer Gleichungssysteme sei. Schon die geringeste √Ñnderung in den Anfangsbedingungen kann eine komplett andere L√∂sung hervorbringen. Diese Beobachtung ging sp√§ter als ¬ª[Schmetterlingseffekt](http://de.wikipedia.org/wiki/Schmetterlingseffekt)¬´ *(¬ªDer Schlag eines Schmetterlingsfl√ºgels in Brasilien kann einen Tornado √ºber Texas hervorrufen.¬´)* in die Geschichte der [Chaostheorie](http://de.wikipedia.org/wiki/Chaostheorie) ein.

Da TigerJython keine eingebaute Bibliothek zur numerischen L√∂sung von Differentialgleichungen besitzt, habe ich das einfache [Eulersche Polygonzugverfahren](https://de.wikipedia.org/wiki/Explizites_Euler-Verfahren) zur numerischen Berechnung herangezogen

~~~python
dx = -sigma*(x - y)*dt
dy = (x*(r - z) - y)*dt
dz = (x*y - b*z)*dt
x += dx
y += dy
z += dz
~~~

und dabei konstant `dt = 0.01` gesetzt. Das ben√∂tigt nat√ºrlich mehr Rechenkapazit√§t, als sie Lorenz je zur Verf√ºgung standen, aber trotz der gr√∂√üeren Genauigkeit √§ndert sich nichts am chaotischen Verhalten der Kurve. F√ºr die Farbberechnung habe ich dieses mal nur den Farbwert (`hue`) bei jeder Iteration ge√§ndert, S√§ttigung und Helligkeit bleiben konstant auf dem h√∂chsten Wert. Das ergibt kr√§ftige Farben, die von Rot √ºber Orange nach Gelb und dann √ºber Gr√ºn, Blau und Violett wieder zur√ºck nach rot wandern. So kann man sch√∂n erkennen, da√ü die beiden ¬ªFl√ºgel¬´ des Attraktors immer wieder, aber f√ºr uns unvorhersehbar, durchlaufen werden.

Um das zu verdeutlichen, habe ich mit

~~~python
hue = ((20*t)%100)/100.0
c = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
~~~

ein wenig getrickst, damit der Farbbereich in Abh√§ngigkeit von den Iterationsschritten der Schleife schneller und gegebenenfalls mehrfach durchlaufen wird.

Au√üerdem wollte ich, da√ü sich der Attraktor langsam aufbaut, damit Ihr die Entstehung der Kurve nachvollziehen k√∂nnt. Normalerweise zeichnet TigerJython alles sofort nach der Berechnung auf den Bildschirm, das hei√üt der Lorenz-Attraktor ist komplett schon nach Sekundenbruchteilen auf dem Monitor zu sehen. Eine schnelle L√∂sung w√§re, bei jedem Iterationsschritt mit `delay(ms)`[^4] eine Pause zu erzwingen. Das f√ºhrt jedoch zu einem Flackern des Bildschirms. Dem kann man wiederum entgehen, indem man das Neuzeichnen in einem Hintergrundspeicher *(Bildbuffer)* ausf√ºhrt und dann erst das fertige Bild in einem Schritt auf den Monitor herausrendert. Dieses Verfahren nennt man **Doppelbufferung**. Bei Animationen wird daher das automatische Rendern der einzelnen Graphikbefehle mit `enableRepaint(False)` deaktiviert und der Bildbuffer zum geeigneten Zeitpunkt mit `repaint()` gerendert.

[^4]: Der Parameter `ms` steht f√ºr Millisekunden.

~~~python
gp.enableRepaint(False)

while(True):
    # Berechne und zeichne das Bild im Hintergrundspeicher
    gp.repaint() # Zeichne das fertige Bild auf den Monitor
    gp.delay(5)  # F√ºnf Millisekunden Pause
    # ‚Ä¶
~~~

Zu guter Letzt ist noch das Problem zu l√∂sen, da√ü sich der klassische Lorenz-Attraktor aus drei unabh√§ngigen Variablen zusammensetzt, TigerJythons *GPanel* aber nur zweidimensional Graphiken darstellen kann. Eine weitverbreitete Methode, dies zu l√∂sen, ist, immer nur zwei Ebenen darzustellen. Angefangen habe ich mit der Darstellung des Attraktors in der x-z-Ebene:

[![Lorenz-Attraktor, x-z-Ebene](images/lorenz1.jpg)](https://www.flickr.com/photos/schockwellenreiter/54575287503/)

Bei der Skalierung auf die Fenstergr√∂√üe habe ich ein wenig geschummelt, um das Fenster jeweils bestm√∂glich auszuf√ºllen. F√ºr die x-z-Ebene habe ich diese Parameter genutzt:

~~~python
xx = (x*8) + 320
zz = 470 - (z*5.5)
    if (t == 0.0):
        gp.move(xx, zz)
    else:
        gp.draw(xx, zz)
~~~

[![Lorenz-Attraktor, y-z-Ebene](images/lorenz2.jpg)](https://www.flickr.com/photos/schockwellenreiter/54575390865/)

In der y-z-Ebene waren es dann diese Parameter:

~~~python
yy = (y*7) + 320
zz = 470 - (z*5.5)
    if (t == 0.0):
        gp.move(yy, zz)
    else:
        gp.draw(yy, zz)
~~~

[![Lorenz-Attraktor, x-y-Ebene](images/lorenz3.jpg)](https://www.flickr.com/photos/schockwellenreiter/54575390860/)

Und in der x-y-Ebene fand ich dann, da√ü diese Skalierungsparameter das Bildschirmfenster optimal ausf√ºllten:

~~~python
xx = (x*8) + 320
yy = 240 - (y*5)
    if (t == 0.0):
        gp.move(xx, yy)
    else:
        gp.draw(xx, yy)
~~~

Denn nicht nur das Hirn, sondern auch das Auge soll sich schlie√ülich an den Ergebnissen erfreuen k√∂nnen. Daf√ºr nimmt man dann schon einmal eine kleine Schummelei in Kauf.&nbsp;ü§ì

Jetzt aber den kompletten Quellcode, damit Ihr auch alles nachvollziehen, nachprogrammieren, aber auch erweitern und ausbauen k√∂nnt:

~~~python
import gpanel as gp
import math, colorsys

WIDTH  = 640
HEIGHT = 480

sigma = -10.0
rho   = 40.0
gamma = 8.0/3
x = y = z = 0.01
t = hue = 0.0
dt = 0.01

gp.makeGPanel(gp.Size(WIDTH, HEIGHT))
gp.window(0, WIDTH, HEIGHT, 0)
gp.windowPosition(1200, 50)
gp.bgColor(gp.Color(33, 41, 70))
gp.title("Lorenz-Attraktor, x-z-Ebene")

gp.enableRepaint(False)

gp.lineWidth(2)
while t < 74.9:
    c = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
    gp.setColor(c)
    # Euler-Integration
    dx = sigma*(x - y)*dt
    dy = (x*(rho - z) - y)*dt
    dz = (x*y - gamma*z)*dt
    x += dx
    y += dy
    z += dz
    # auf Fenstergr√∂√üe skalieren
    # Skalierungsparameter f√ºr die Fenstergr√∂√üe:
    # x-z-Ebene: xx = (x*8) + 320, zz = 470 - (z*5.5)
    # y-z-Ebene: yy = (y*7) + 320, zz = 470 - (z*5.5)
    # x-y-Ebene: xx = (x*8) + 320, yy = 240 - (y*5)
    xx = (x*8) + 320
    zz = 470 - (z*5.5)
    if (t == 0.0):
        gp.move(xx, zz)
    else:
        gp.draw(xx, zz)
    gp.repaint()
    gp.delay(5)
    t += dt
    hue = ((20*t)%100)/100.0

print("I did it, Babe!")
~~~

Wie bei (fast) allen meinen TigerJython-Experimenten gibt es den [Quellcode](https://gitlab.com/kantel/tigerjython/-/blob/master/fraktale/lorenz01.py) nat√ºrlich auch in meinem GitLab-Repositorium.

### Literatur

- Karl-Heinz Becker, Michael D√∂rfler: *Kochrezepte f√ºr Fraktale. Computergrafische Experimente mit Python*, Bremen 2024
- Sau Sheong Chang: *Exploring Everyday Things with R and Ruby*, Sebastopol (O‚ÄôReilly) 2012
- James Gleick: *CHAOS ‚Äì die Ordnung des Universums. Vorsto√ü in Grenzbereiche der modernen Physik*, M√ºnchen (Knaur Taschenbuch) 1990
- Dietmar Hermann: *Algorithmen f√ºr Chaos und Fraktale*, Bonn (Addison-Wesley) 1994
- Frank Piefke: *Simulationen mit dem Personalcomputer*, Heidelberg (H√ºthig) 1991
- Karline Soetaert, Peter M.J. Hermann: *A Practical Guide to Ecological Modelling: Using R as a Simulation Platform*, o.O. (Springer Netherlands) 2009
- Ian Stewart: *Spielt Gott Roulette?* Frankfurt (Insel TB) 1993

Einen ausf√ºhrlichen Bericht von *Eric W. Weisstein* √ºber den [Lorenz-Attractor](https://mathworld.wolfram.com/LorenzAttractor.html) mit vielen weiteren Literaturhinweisen gibt es auf der Wolfram Mathworld. 