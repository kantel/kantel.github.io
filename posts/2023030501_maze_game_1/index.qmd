---
title: "Abenteuer Trinket: Maze Game Stage 1"
author: "J√∂rg Kantel"
date: "2023-03-05 20:30:00"
categories: [Trinket, Python, Turtle, Spieleprogrammierung]
image: "images/mazegame1.jpg"
---

[![](images/mazegame1-b.jpg)](https://www.flickr.com/photos/schockwellenreiter/52727313297/)

Das Abenteuer [Trinket](http://cognitiones.kantel-chaos-team.de/programmierung/python/trinket.html) geht weiter, denn die Besch√§ftigung mit dieser extrem leistungsf√§higen Online-IDE macht einfach Spa√ü. Daher habe ich ein weiteres Spiel hervorgekramt, das ich [schon vor einem Jahr](http://blog.schockwellenreiter.de/2022/04/2022041901.html) in [Pygame Zero](http://cognitiones.kantel-chaos-team.de/multimedia/spieleprogrammierung/pygamezero.html) implementiert hatte. Damals sollte es eigentlich als k√ºnftige Blaupause f√ºr mein Projekt ¬ª[Retrogaming und K√ºnstliche Intelligenz](http://blog.schockwellenreiter.de/2022/04/2022041401.html)¬´ dienen. Dann war ich jedoch zu der √úberzeugung gekommen, da√ü Pygame Zero doch nicht die richtige Umgebung daf√ºr sei. Eigentlich tendierte ich dann zu [Pygame](http://cognitiones.kantel-chaos-team.de/multimedia/spieleprogrammierung/pygame.html), ohne die Idee jedoch weiter zu verfolgen. Vielleicht bringt nun Trinket (das ja sowohl eine Art von [Processing](http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processing.html)([.py](http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processingpy.html)) wie auch eine Turtle bewegen kann) wieder neuen Schwung in die Angelegenheit.

<iframe width="560" height="315" src="https://www.youtube.com/embed/inocKE13DEA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

Auf jeden Fall habe ich mir daf√ºr zum wiederholten Male die Playlist ¬ª[Python Maze Game Tutorial](https://www.youtube.com/playlist?list=PLlEgNdBJEO-lNDJgg90fmfAq9RzORkQWP)¬´ von *Christian Thompson*[^1] hereingezogen und begonnen, daraus eine Version in Trinket zu erstellen. W√§hrend mein [letzter Versuch mit Trinket und der Turtle](https://kantel.github.io/posts/2023030201_space_war_trinket/) alles rausholte, was aus Trinket rauszuholen war, sollte es diesmal etwas anf√§ngerfreundlicher und √ºbersichtlicher werden. Daher sind auch mehrere Lieferungen geplant.

[^1]: Ich kann auch dies nicht oft genug wiederholen: *[Christian Thompson](https://christianthompson.com/)* aka *Tokyo Edtech* ist der Mann, der Unglaubliches mit [Pythons (Standard-) Turtle](https://docs.python.org/3/library/turtle.html) anstellt.

<iframe src="https://trinket.io/embed/python/46a2d36061?outputOnly=true&runOption=run&start=result" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>

Die heutige erste Lieferung zeigt ein kleines Labyrinth[^2], durch das der mit den Pfeiltasten gesteuerte Spieler irren kann. Er kann auf seinem Irrweg drei Schatzk√§stlein leeren und schlie√ülich auch unten rechts den Irrgarten verlassen. Damit endet dann auch das Spiel.

[^2]: Ich wei√ü, es ist strenggenommen kein [Labyrint](https://de.wikipedia.org/wiki/Labyrinth), sondern ein [Irrgarten](https://de.wikipedia.org/wiki/Irrgarten). Aber da im Deutschen beide Begriffe oft synonym verwendet werden, habe auch ich mir diese kleine, sprachliche Ungenauigkeit erlaubt.

Im Gegensatz zu der Version von *Christian Thompson*, der -- bedingt durch die Einschr√§nkungen von Pythons Standard-Turtle -- nur 24x24 Pixel gro√üe Sprites vewenden konnte, konnte ich -- da Trinket hier keine Einschr√§nkungen besitzt -- auf 16x16 gro√üe Tiles und Sprites zur√ºckgreifen. In der momentanen Version habe ich f√ºr die Mauern ein Tile aus Kenneys -- wie immer freien ([CCO 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/))  -- [1-Bit-Pack](https://www.kenney.nl/assets/bit-pack) verwendet, da es zwischen den einzelnen Elementen jeweils einen Rand l√§√üt, so da√ü man den Aufbau des Irrgarten nachvollziehen kann. Sp√§ter m√∂chte ich jedoch -- wie hier schon [angek√ºndigt](https://kantel.github.io/posts/2023022701_turtle_trinket/) -- auf Kenneys ebenfalls unter *CCO 1.0 Universal* stehende [Tiny Dungeon Tileset](https://kenney.nl/assets/tiny-dungeon) nebst der dazugeh√∂renden [Tiny Town Erweiterung](https://kenney.nl/assets/tiny-town) zur√ºckgreifen. Die Figur des Zauberers wie auch die Schatzk√§stlein habe ich jedenfalls schon aus diesem Tile- und Spriteset entnommen[^3].

[^3]: Falls mir dann dennoch die Bildchen ausgehen sollten: Auch Kenneys [Pixel Plattformer](https://www.kenney.nl/assets/pixel-platformer) pa√üt von der Anmutung her noch gut in diese Sammlung.

Doch jetzt erst einmal den kompletten Quellcode, damit Ihr das Spiel nachvollziehen und auf Wunsch auch eweitern k√∂nnt:

~~~python
import turtle, math

WIDTH, HEIGHT = 440, 440
WALL   = 63
DOOR   = 62
CHEST  = 22
PLAYER = 10
TILESIZE = 16

maze_map_0 = [[63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63],
            [63,10,-1,63,63,63,63,63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,63,63,63,63,63],
            [63,-1,-1,63,63,63,63,63,63,63,-1,-1,63,63,63,63,63,63,-1,-1,63,63,63,63,63],
            [63,-1,-1,-1,-1,-1,-1,-1,63,63,-1,-1,63,63,63,63,63,63,-1,-1,63,63,63,63,63],
            [63,-1,-1,-1,-1,-1,-1,-1,63,63,-1,-1,63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,63,63],
            [63,63,63,63,63,63,-1,-1,63,63,-1,-1,63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,63,63],
            [63,63,63,63,63,63,-1,-1,63,63,-1,-1,63,63,63,63,63,63,-1,-1,63,63,63,63,63],
            [63,63,63,63,63,63,-1,-1,63,63,-1,-1,-1,-1,63,63,63,63,-1,-1,63,63,63,63,63],
            [63,-1,-1,63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,63,63,63,63,22,-1,63,63,63,63,63],
            [63,-1,-1,63,63,63,-1,-1,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63],
            [63,-1,-1,-1,-1,-1,-1,-1,-1,-1,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63],
            [63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,63,63,63,63,63,63,63,63],
            [63,63,63,63,63,63,63,63,63,63,63,63,-1,-1,-1,-1,-1,63,63,63,63,63,-1,22,63],
            [63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,-1,-1,63,63,63,63,63,-1,-1,63],
            [63,-1,-1,63,63,63,63,63,63,63,63,63,63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,-1,63],
            [63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,63],
            [63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,63,63,63,63,63,63,63,63,63,63,63,63,63],
            [63,63,63,63,63,63,63,63,63,63,-1,-1,63,63,63,63,63,63,63,63,63,63,63,63,63],
            [63,63,63,63,63,63,63,63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,63],
            [63,22,-1,-1,63,63,63,63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,63],
            [63,-1,-1,-1,63,63,63,63,63,63,63,63,63,63,63,63,63,63,-1,-1,63,63,63,63,63],
            [63,-1,-1,-1,-1,-1,63,63,63,63,63,63,63,63,63,63,63,63,-1,-1,63,63,63,63,63],
            [63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,63,63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,63],
            [63,63,63,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62],
            [63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63]]

screen = turtle.Screen()
screen.setup(WIDTH, HEIGHT)
screen.bgcolor("#2b3e50")

# Bildschirm-Refresh ausschalten
screen.tracer(0)

# Die Turtle-Bilder registrieren
images = ["wall1.png", "wizard.png", "chest.png", "key.png"]
for image in images:
  screen.addshape(image)

class Player(turtle.Turtle):
  
  def __init__(self):
    turtle.Turtle.__init__(self)
    self.penup()
    self.right(270)
    self.shape("wizard.png")
    self.speed(0)
    self.gold = 0
    
  # Player Movement
  def go_up(self):
    next_x, next_y = self.xcor(), self.ycor() + TILESIZE
    if (next_x, next_y) not in walls:
      self.goto(next_x, next_y)
    
  def go_down(self):
    next_x, next_y = self.xcor(), self.ycor() - TILESIZE
    if (next_x, next_y) not in walls:
      self.goto(next_x, next_y)
    
  def go_left(self):
    next_x, next_y = self.xcor() - TILESIZE, self.ycor()
    if (next_x, next_y) not in walls:
      self.goto(next_x, next_y)
    
  def go_right(self):
    next_x, next_y = self.xcor() + TILESIZE, self.ycor()
    if (next_x, next_y) not in walls:
      self.goto(next_x, next_y)
      
  # Kollisionserkennung (Pythagoras)
  def is_collision(self, other):
    a = self.xcor() - other.xcor()
    b = self.ycor() - other.ycor()
    distance = math.sqrt((a**2) + (b**2))
    if distance < 5:
      return True
    else:
      return False

class Wall(turtle.Turtle):
  
  def __init__(self):
    turtle.Turtle.__init__(self)
    self.penup()
    self.shape("wall1.png")
    self.speed(0)

class Chest(turtle.Turtle):
  
  def __init__(self, _x, _y):
    turtle.Turtle.__init__(self)
    self.penup()
    self.right(270)
    self.shape("chest.png")
    self.speed(0)
    self.gold = 100
    self.goto(_x, _y)
  
  def destroy(self):
    self.goto(2000, 2000)
    self.hideturtle()
  
levels = []
levels.append(maze_map_0)

def setup_maze(level):
  for y in range(len(level)):
    for x in range(len(level[y])):
      # Get the mumber of every item in the mace
      item_number = level[y][x]
      # Berechne die Bildschirmkoordinaten
      screen_x = -192 + (x*TILESIZE)
      screen_y =  192 - (y*TILESIZE)
      
      # Pr√ºfe, ob Item ein Wall ist
      if item_number == WALL:
        wall.goto(screen_x, screen_y)
        wall.stamp()
        walls.append((screen_x, screen_y))
        
      # Pr√ºfe, ob Item der Spieler ist
      if item_number == PLAYER:
        player.goto(screen_x, screen_y)
        
      # Pr√ºfe, ob Item eine Schatztrue ist
      if item_number == CHEST:
        chests.append(Chest(screen_x, screen_y))

wall = Wall()
walls = []
chests = []
player = Player()

# Level Setup
setup_maze(levels[0])

# Das Spiel beenden
def exit_game():
  global keep_going
  print("Bye, bye, Baby")
  keep_going = False

# Auf Tastaturereignisse lauschen
screen.listen()
screen.onkey(player.go_up, "Up")
screen.onkey(player.go_down, "Down")
screen.onkey(player.go_left, "Left")
screen.onkey(player.go_right, "Right")

screen.onkey(exit_game, "q")   # Das Spiel beenden

# Spiel starten
print("üßô Simple Maze Game Stage 1 üßô")
keep_going = True
while keep_going:
  # Hat der Spieler eine Schatzkiste gefunden?
  for chest in chests:
    if player.is_collision(chest):
      player.gold += chest.gold
      print("Player Gold: {}".format(player.gold))
      # Verberge die Schatzkiste
      chest.destroy()
      # L√∂sche die Schatzkiste aus der Liste
      chests.remove(chest)
  # Ist der Spieler dem Labyrint entkommen?
  if player.xcor() > 192:
    print("**Gewonen!**")
    exit_game()
    
  screen.update()   # den gesamten Bildschirm neu zeichnen
~~~

Nat√ºrlich gibt es das [Spiel als Trinket](https://trinket.io/library/trinkets/46a2d36061) und den [Quellcode und alle bisher benutzten Bildchen](https://github.com/kantel/trinket/tree/main/maze_game/stage1/mazegame1) habe ich auch auf GitHub hochgeladen.

Bisher habe ich nur eine vage Vorstellung davon, wie ich weitermachen soll. Ich bin daher mindestens genau so gespannt wie Ihr, wohin die Reise geht. *Still digging!*