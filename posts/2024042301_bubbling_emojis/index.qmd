---
title: "MicroStudio und Python: Bubbly Emojis"
author: "J√∂rg Kantel"
date: "2024-04-23 22:45:00"
categories: [microStudio, Python, Creative Coding]
image: "images/pythontutorial10.jpg"
---

[![](images/pythontutorial10-b.jpg)](https://www.flickr.com/photos/schockwellenreiter/53673195352/)

Eigentlich wollte ich meine Experimente mit [microStudio](http://cognitiones.kantel-chaos-team.de/multimedia/spieleprogrammierung/microstudio.html) und Python/[Brython](http://cognitiones.kantel-chaos-team.de/programmierung/python/brython.html) ja mal f√ºr eine Weile [unterbrechen](https://kantel.github.io/posts/2024042102_tuesdayjs_47/) und mich anderen Aspekten der kreativen Programmierung zuwenden, doch dann sp√ºlte das Video ¬ª[Bubbly Emoji Effect](https://www.youtube.com/watch?v=Rd1eeHEx_fM)¬´ von *Patt Vira* in meinen Feedreader. Und diese kreative [P5.js](http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/p5js.html)-Spielerei faszinierte mich so, da√ü ich eine eigene Version davon unbedingt in microStudio mit Python implementieren mu√üte.

<iframe src="pythontutorial10/index.html" class="if16_9" name="Bubbly Emojis"></iframe>

F√ºr diese Spielerei habe ich wieder meine [PVector2-Klasse](https://kantel.github.io/posts/2024032801_microstudio_noc_1/) genutzt, die Ihr -- falls Ihr das nachprogrammieren wollt -- ebenfalls in Euren Quellcode kopieren m√º√üt. Und damit alles sch√∂n objektorientert vonstatten geht, habe ich den Luftblasen-Emojis eine eigene Klasse spendiert:

~~~python
from random import uniform, choice

class Emoji:
  
  def __init__(self, _x, _y):
    self.loc = PVector2(_x, _y)
    self.vel = PVector2(uniform(-0.5, 0.5), uniform(3, 1))
    self.done = False
    self.size = 30
    self.t = choice(emojis_pics)
  
  def update(self):
    self.loc.add(self.vel)
    if self.size <= 1:
      self.done = True
    else:
      self.size -= 0.5 
  
  def display(self):
    screen.drawText(self.t, self.loc.x, self.loc.y + self.size/2, self.size)
~~~

Da es nahezu kein kreatives Programmieren ohne (Pseudo-) Zufallszahlen gibt, habe ich die Funktionen `uniform()` und `choice()` aus Pythons `random`-Bibliothek importiert. Jedes Emoji besitzt einen Vektor f√ºr den Ort (`loc`) und einen zuf√§llig erzeugten Vektor f√ºr die Bewegung nach oben (`vel`). Und aus einer Liste von Emojis wird mit `random.choice()` zuf√§llig eines ausgew√§hlt.

In der `update()`-Methode wird das Emoji bewegt, indem die *Velocity* zur *Position* (`loc`) hinzuaddiert wird. Dann wird noch √ºberpr√ºft, ob die Gr√∂√üe des Emojis $1$ erreicht oder unterschritten hat. Hat sie das, wird die Eigenschaft `done` auf `True` gesetzt, wenn nicht, wird die Gr√∂√üe um $0.5$ verringert.

Die `display()`-Methode nutzt `screen.drawText()` um das Emoji auf den Bildschirm zu bringen.

Die eigentliche Programmlogik √ºbernimmt dieses Mal die Hauptroutine `main`:

~~~python
emojis = []
emojis_pics = ["ü§ì", "üòé", "ü§°", "üíÄ", "ü§ñ", "üéÉ",
               "üëΩ", "üòà", "üëπ"]
def init():
  pass

def update():
  if mouse.pressed and mouse.left:
    emoji = Emoji(mouse.x, mouse.y)
    emojis.append(emoji)
  for emoji in reversed(emojis):
    if emoji.done:
      emojis.remove(emoji)
  for emoji in emojis:
    emoji.update()
  # if len(emojis) >= 40:
  #   system.pause()
  
def draw():
  screen.clear()
  screen.fillRect(0, 0, screen.width, screen.height, "rgb(234, 218, 184)")
  for emoji in emojis:
    emoji.display()
~~~ 

Zuerst wird global eine leere Liste f√ºr die einzelnen Emojis erzeugt und die (konstante) Liste mit den Bildern der Emojis angelegt. Die `init()`-Funktion bleibt dieses Mal ungenutzt. Da microScript sie aber dennoch stur aufrufen will, mu√ü sie als leere Funktion (mit dem Befehl `pass`) implementiert werden.

Daf√ºr erledigt die `update()`-Funktion von `main` die ganze Arbeit: Zuerst wird -- solange die linke Maustaste gedr√ºckt ist (`if mouse.pressed and mouse.left`) -- ein neues Emoji angelegt und der Liste `emojis` hinzugef√ºgt. Damit diese Liste aber nicht ins Unerme√üliche w√§chst, wurde ja schon in der `update()`-Methode der Klasse `Emoji` √ºberpr√ºft, ob die Gr√∂√üe $1$ erreicht oder unterschritten hat in diesem Falle `done` auf `True` gesetzt. Daher sollen nun alle Emojis, die kleiner oder gleich $1$ sind, gel√∂scht werden. Geht man aber hierf√ºr die Liste von vorne nach hinten durch, l√§uft man in Gefahr, da√ü einzelne Elemente √ºbersprugen werden, da sie mit ihrem Index auf die Position eines schon gel√∂schten Elements verschoben werden. Daher ist es eine g√§ngige Methode, L√∂schoperationen vorzunehmen, in dem man die Liste r√ºckw√§rts durchl√§uft, denn dann stehen alle gel√∂schten Elemente oberhalb des aktuellen Indizes. Python besitzt daf√ºr einen genialen Shortcut,

~~~python
  for emoji in reversed(emojis):
    if emoji.done:
      emojis.remove(emoji)
~~~

der mit `reversed(liste)` die Elemente der Liste r√ºckw√§rts durchl√§uft und mit `remove(element)` die gew√ºnschten Listenelemente aus der Liste entfernt.

Zu guter Letzt wird dann nur noch f√ºr jedes Emoji aus der (schon gek√ºrzten) Emojis-Liste die `update()`-Methode aufgerufen. (Die auskommentierten Zeilen dienten nur der Anfertigung des Screenshots.)

Die `draw()`-Funktion ist wieder simpel: Bei jedem Durchlauf wird der Bildschirm gel√∂scht, dann √ºber die ganze Gr√∂√üe des Bildschirms ein gef√ºlltes Rechteck mit der Hintergrundfarbe gezogen und letztendlich jedes noch verbliebene Emoji in der aktuellen Gr√∂√üe an der aktuellen Position gezeichnet.

Das war es dann auch schon. Dieses ist das zehnte Tutorial meiner kleinen Reihe zu microStudio mit Python. Alle bisher erschienenen Tutorien sind hier aufgelistet:

- MicroStudio und Python (Teil 1): [Hallo Brython](https://kantel.github.io/posts/2024032201_microstudio_python_1/)!
- MicroStudio und Python (Teil 2): [Zombie Apokalypse](https://kantel.github.io/posts/2024032401_microstudio_python_2/)
- MicroStudio und Python (Teil 3): [Dancing Crab](https://kantel.github.io/posts/2024032502_microstudio_python_3/)
- MicroStudio und Python (Teil 4): [Flying Badger](https://kantel.github.io/posts/2024032703_flying_badger_python/)
- MicroStudio und Python (Teil 5): [PVector2 und ¬ªThe Nature of Code¬´](https://kantel.github.io/posts/2024032801_microstudio_noc_1/)
- MicroStudio und Python (Teil 6): [Bouncing Balls](https://kantel.github.io/posts/2024033102_bouncing_balls_microstudio/)
- MicroStudio und Python (Teil 7): [Kollisionserkennung mit Kreisen](https://kantel.github.io/posts/2024040201_collision_detection_1/)
- MicroStudio und Python (Teil 8): [Bouncing Birds](https://kantel.github.io/posts/2024040401_bouncing_birds/)
- MicroStudio und Python (Teil 9): [Kollisionserkennung mit Rechtecken](https://kantel.github.io/posts/2024040701_rect_collision/)
- MicroStudio und Python (Teil 10): Bubbly Emojis 

Und nat√ºrlich habe ich auch dieses Tutorial wieder auf meinem [microStudio-Account hochgeladen](https://microstudio.dev/i/kantel/pythontutorial10/).

*Patt Vira*, die die Inspration zu diesem Tutorial gab, hat noch weitere, interessante Videos auf ihrem [YouTube-Account](https://www.youtube.com/@pattvira) ver√∂ffentlicht, die geradezu nach einem Port nach microStudio schreien. Spontan fallen mir diese ein:

- [üíñ Exploding Hearts üíñ](https://www.youtube.com/watch?v=YgDY7l2W9eE) ‚Äì [Quellcode](https://editor.p5js.org/pattvira/sketches/B7jG_ZOl0)
- [Interactive Floating Typography](https://www.youtube.com/watch?v=-6v_AYyn49k) ‚Äì [Quellcode](https://editor.p5js.org/pattvira/sketches/Rs498E8W3)
- [Interactive Falling Text Rain](https://www.youtube.com/watch?v=vVXizarOnrU) ‚Äì [Quellcode](https://editor.p5js.org/pattvira/sketches/I6nhJ_Ffq)

Sie alle sind Teil der Playlist [Interactivity](https://www.youtube.com/playlist?list=PL0beHPVMklwgEn3BSVCMssJOD165ZQiw7), die zur Zeit aus dreizehn Videos mit witzigen Projekten besteht. Da das j√ºngste Update erst wenige Stunden alt ist, rechne ich noch mit weiteren Tutorials. Schaun wir doch mal, was ich damit alles anstellen kann. *Still digging!*