---
title: "Waldbrandsimulation in Python (Py5) -- Stage&nbsp;1"
author: "JÃ¶rg Kantel"
date: "2023-09-23 19:40:00"
categories: [Python, Simulation, Py5, Processing]
image: "images/forestfiresimstage1.jpg"
---

[![](images/forestfiresimstage1-b.jpg)](https://www.flickr.com/photos/schockwellenreiter/53206780452/)

Ich habe es getan: Ich habe mir das [hier vorgestellte](https://kantel.github.io/posts/2023092001_game_engines_und_mehr/) Waldbrand-Simulation von *Al Sweigart* und meine eigene, in [Processing.py](http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/processingpy.html) implementierte [Version](http://py.kantel-chaos-team.de.s3-website-us-east-1.amazonaws.com/12zellautom/#der-waldbrand-simulator) geschnappt und daraus eine -- wie ich hoffe -- verbesserte Fassung in [Py5](http://cognitiones.kantel-chaos-team.de/programmierung/creativecoding/processing/py5.html) programmiert.

Zwei grundsÃ¤tzliche Ã„nderungen gegenÃ¼ber dem Programm von *Al Sweigart* habe ich vorgenommen: Zum einen habe ich die Randbedingungen vereinfacht, indem ich die Felder an den RÃ¤ndern grundsÃ¤tzlich leer gelassen habe (der Wald hÃ¶rt also nicht an den RÃ¤ndern, sondern ein Zeile oder Spalte davor auf). Das Ã¤ndert nichts an dem Verhalten der Simulation (der Wald ist einfach nur je eine Zeile oben und unten und je eine Spalte rechts und links kleiner), erspart der Programmiererin oder dem Programmierer aber eine Menge Arbeit bei der Behandlung der RÃ¤nder: Wenn die Abfragen immer nur von `range(1, N_ROWS-1)` respektive von `range(1, N_COLS-1)` reichen, kÃ¶nnen sie nie die Dimensionen einers zweidimendionalen Arrays sprengen.

Die zweite Ã„nderung bedarf schon einer grÃ¶ÃŸeren Diskussion: Statt der [Moore-Nachbarschaft](http://cognitiones.kantel-chaos-team.de/programmierung/softcomputing/moorenb.html), die von *Al Sweigart* verwendet wurde und bei der alle acht Nachbarfelder einer Zelle abgefragt werden, habe ich die [Von-Neumann-Nachbarschaft](http://cognitiones.kantel-chaos-team.de/programmierung/softcomputing/neumannnb.html) verwendet, bei der nur die vier Zellen, die eine Kante mit der BasisflÃ¤che gemeinsam haben, als Nachbarn berÃ¼cksichtigt werden. Diese Nachbarschaft habe ich aus pragmatischen GrÃ¼nden gewÃ¤hlt, da die Abfrage von vier statt von acht Nachbarn den Code halbiert. Und ich denke, daÃŸ man die Wahl damit begrÃ¼nden kann, daÃŸ die diagonal entfernten Felder, die nur eine Ecke mit der Basiszelle gemeinsam haben, weiter entfernt von der Basiszelle liegen und daher weniger der Brandgefahr ausgesetzt sind. Ich befinde mich da in guter Gesellschaft, da auch in der einschlÃ¤gigen Literatur fast immer die *Von-Neumann-Nachbarschaft* Verwendung findet[^1]. AuÃŸerdem habe ich keine grundsÃ¤tzliche Ã„nderung im Verhalten der Simulation bei Verwendung der *Moore-Nachbarschaft* feststellen kÃ¶nnen.

[^1]: Vergleiche Peitgen, JÃ¼rgens, Saupe: *Bausteine des Chaos -- Fraktale*, Berlin-Heidelberg-Stuttgart (Klett-Cotta/Springer) 1992, Seiten 424ff. oder Scholz: *Pixelspiele*, Berlin-Heidelberg (Springer) 2014, Seiten 19ff.

Das Modell hat in seiner einfachsten Form drei Paramter, an denen geschraubt werden kann und die EinfluÃŸ auf den Verlaut der Simulation haben: Es sind mit `a` die Wahrscheinlichkeit, mit der ein einem Feld ein Baum (nach-) wÃ¤chst, `b` die Wahrscheinlichkeit, mit der ein Baum (zum Beispiel durch Blitzeinschlag) Feuer fÃ¤ngt und `s` die Wahrscheinlichkeit, mit welcher Dichte beim Start das Feld mit BÃ¤umen besetzt ist. Sowohl bei Sweigart wie auch bei Scholz finden sich weiter Ideen, wie die Siumlation erweitert und ausgebaut werden kann.

Doch jetzt erst einmal das komplette Programm, damit Ihr die Simulation nachlesen, nachprogrammieren oder mit eigenen Ideen erweitern kÃ¶nnt:

~~~python
## Forest Fire Simulation
from random import randint, uniform

TS = 16       # Tilesize
N_ROWS, N_COLS = 40, 30
PLOT_WIDTH = 720
PLOT_HEIGHT = N_COLS*TS
SCREEN_WIDTH, SCREEN_HEIGHT = N_ROWS*TS, N_COLS*TS   # 640x480 Pixel

empty = 0
tree = 1
burning = 20
w = h = TS

a = 4.0        # Wachstumswahrscheinlichkeit in Prozent
b = 0.2        # Wahrscheinlichkeit Blitzeinschlag in Prozent
s = 50         # Startbepflanzung in Prozent

grid = []
newgrid = []

trees = []
fires = []

def setup():
    global tree_image, fire_image, no_trees, no_fire
    size(SCREEN_WIDTH, SCREEN_HEIGHT)
    window_title("ğŸŒ² Forest Fire Simulation ğŸ”¥")
    window_move(1300, 30)
    tree_image = load_image("data/tree.png")
    fire_image = load_image("data/fire.png")
    no_trees = no_fire = 0
    create_new_forest()
    newgrid[:] = grid[:]
    frame_rate(1)
    print("Start: BÃ¤ume = ", no_trees, " BrÃ¤nde = ", no_fire)
    trees.append(no_trees)
    fires.append(no_fire)
    
def draw():
    background(210, 180, 140)
    print("Runde: ", frame_count, " BÃ¤ume = ", no_trees, " BrÃ¤nde = ", no_fire)
    display_plot()
    trees.append(no_trees)
    fires.append(no_fire)
    display_forest()
    calc_next()
    if frame_count == 30:
        no_loop()

def display_plot():
    pass

def create_new_forest():
    global no_trees
    for x in range(N_ROWS):
        grid.append([])
        newgrid.append([])
        for y in range(N_COLS):
            # Erstbepflanzung Wald
            if ((x > 0) and (y > 0) and (x < N_ROWS - 1)
                and (y < N_COLS - 1) and randint(0, 100) <= s):
                grid[x].append(tree)
                no_trees += 1
            else:
                # RÃ¤nder bleiben leer
                grid[x].append(empty)

def display_forest():
    for i in range(N_ROWS):
        for j in range(N_COLS):
            if grid[i][j] == tree:
                image(tree_image, i*w, j*h, w, h)
            elif grid[i][j] == burning:
                image(fire_image, i*w, j*h, w, h)

def calc_next():
    global no_trees, no_fire
    newgrid[:] = grid[:]
    # Next Generation, Randfelder ignorieren
    for i in range(1, N_ROWS - 1):
        for j in range(1, N_COLS - 1):
            if grid[i][j] == burning:
                newgrid[i][j] = empty
                no_fire -= 1
                # Nachbarbaum anzÃ¼nden (von-Neumann-Nachbarschaft)
                if grid[i-1][j] == tree:
                    newgrid[i-1][j] = burning
                    no_trees -= 1
                    no_fire += 1
                if grid[i][j-1] == tree:
                    newgrid[i][j-1] = burning
                    no_trees -= 1
                    no_fire += 1
                if grid[i][j+1] == tree:
                    newgrid[i][j+1] = burning
                    no_trees -= 1
                    no_fire += 1
                if grid[i+1][j] == tree:
                    newgrid[i+1][j] = burning
                    no_trees -= 1
                    no_fire += 1
            ## Neuer Baum?
            elif grid[i][j] == empty:
                if uniform(0, 100) < a:
                    newgrid[i][j] = tree
                    no_trees += 1
            # SchlÃ¤gt ein Blitz ein?
            if grid[i][j] == tree:
                if uniform(0, 100) < b:
                    newgrid[i][j] = burning
                    no_fire += 1
    grid[:] = newgrid[:]
~~~

In dem Skript sind schon Slots offengehalten, um einen Plot des Simulationsverlaufes zu erstellen. Leider weigert sich die [Matplotlib](http://cognitiones.kantel-chaos-team.de/programmierung/python/matplotlib.html) hartnÃ¤ckig, mit Py5 zusammenzuarbeiten. Daher ist meine Idee, [FPlotter](http://blog.schockwellenreiter.de/2021/03/2021031901.html) ([2](http://blog.schockwellenreiter.de/2021/03/2021033002.html)), meine in Processing.py implementierte Â»Matplotlib fÃ¼r ArmeÂ« wieder zu reaktivieren und in dieser Simulation einzusetzen. Das wird vermutlich mein nÃ¤chster Schritt sein.

Ansionsten gibt es den [Quellcode](https://github.com/kantel/py5/tree/main/forestfire) wie immer in meinem GitHub-Repositorium und die [Bilder](https://github.com/kantel/py5/tree/main/forestfire/data) habe ich den freien ([CC-BY 4.0](https://creativecommons.org/licenses/by/4.0/)) [Twemojis](https://twemoji.twitter.com/) von Twitter entnommen und mit einem Graphikprogramm meines Vertrauens auf 16x16 Pixel verkleinert.

### Verwendete Literatur:

- Heinz-Otto Peitgens, Hartmut JÃ¼rgens und Dietmar Saupe: *Bausteine des Chaos -- Fraktale*, Berlin-Heidelberg-Stuttgart (Springer, Klett-Cotta) 1992
- Daniel Scholz: *Pixelspiele -- Modellieren und Simulieren mit zellulÃ¤ren Automaten*, Berlin-Heidelberg (Springer) 2014
- Al Sweigart: *[The Big Book of Small Python Projects](https://inventwithpython.com/bigbookpython/) -- 81 Easy Practice Programs*, San Francisco (No Starch Press) 2021